// Generated by ReScript, PLEASE EDIT WITH CARE

import * as RegexAst from "./RegexAst.bs.js";
import * as Belt_SetString from "@rescript/std/lib/es6/belt_SetString.js";

function stringifyQuanifier(kind) {
  if (typeof kind === "string") {
    if (kind === "OneOrMore") {
      return "+";
    } else {
      return "?";
    }
  }
  var variant = kind.NAME;
  if (variant !== "MinMax") {
    if (variant === "Exact") {
      return "{" + (String(kind.VAL) + "}");
    } else {
      return "*" + (
              kind.VAL === "Lazy" ? "?" : ""
            );
    }
  }
  var match = kind.VAL;
  var min = match[0];
  if (min !== undefined) {
    var max = match[1];
    if (max !== undefined) {
      return "{" + (String(min) + ("," + (String(max) + "}")));
    } else {
      return "{" + (String(min) + ",}");
    }
  }
  var max$1 = match[1];
  if (max$1 !== undefined) {
    return "{," + (String(max$1) + "}");
  } else {
    return "{,}";
  }
}

function stringifyNode(node, parents) {
  var id = function (x) {
    return x;
  };
  var stringify = function (_node, _parents, _k) {
    while(true) {
      var k = _k;
      var parents = _parents;
      var node = _node;
      if (typeof node === "number") {
        return k("");
      }
      switch (node.TAG | 0) {
        case /* Match */0 :
            var str = node._0;
            if (str.TAG === /* Exact */0) {
              return k(str._0);
            } else {
              return k("[" + ((
                            str.negative ? "^" : ""
                          ) + (str.chars.map(function (kind) {
                                    if (kind.NAME !== "Range") {
                                      return kind.VAL;
                                    }
                                    var match = kind.VAL;
                                    return match[0] + ("-" + match[1]);
                                  }).join("") + "]")));
            }
        case /* ConcatExpr */1 :
            var right = node.right;
            var left = node.left;
            if (node.kind === "Conjunction") {
              _k = (function(node,parents,k,right){
              return function (leftStr) {
                return stringify(right, {
                            hd: node,
                            tl: parents
                          }, (function (rightStr) {
                              return k(leftStr + rightStr);
                            }));
              }
              }(node,parents,k,right));
              _parents = {
                hd: node,
                tl: parents
              };
              _node = left;
              continue ;
            }
            if (parents) {
              var match = parents.hd;
              var exit = 0;
              if (typeof match !== "number") {
                switch (match.TAG | 0) {
                  case /* ConcatExpr */1 :
                      if (match.kind === "Disjunction") {
                        exit = 2;
                      }
                      break;
                  case /* NonCaptureGroup */4 :
                  case /* CaptureGroup */5 :
                      exit = 2;
                      break;
                  default:
                    
                }
              }
              if (exit === 2) {
                _k = (function(node,parents,k,right){
                return function (leftStr) {
                  return stringify(right, {
                              hd: node,
                              tl: parents
                            }, (function (rightStr) {
                                return k(leftStr + ("|" + rightStr));
                              }));
                }
                }(node,parents,k,right));
                _parents = {
                  hd: node,
                  tl: parents
                };
                _node = left;
                continue ;
              }
              
            }
            _k = (function(node,parents,k,right){
            return function (leftStr) {
              return stringify(right, {
                          hd: node,
                          tl: parents
                        }, (function (rightStr) {
                            return k("(?:" + (leftStr + ("|" + (rightStr + ")"))));
                          }));
            }
            }(node,parents,k,right));
            _parents = {
              hd: node,
              tl: parents
            };
            _node = left;
            continue ;
            break;
        case /* QuantifierExpr */2 :
            var node$1 = node.node;
            var exit$1 = 0;
            if (typeof node$1 === "number") {
              _parents = {
                hd: node,
                tl: parents
              };
              _node = node$1;
              continue ;
            }
            switch (node$1.TAG | 0) {
              case /* Match */0 :
                  exit$1 = node$1._0.TAG === /* Exact */0 ? 1 : 2;
                  break;
              case /* NonCaptureGroup */4 :
              case /* CaptureGroup */5 :
                  exit$1 = 2;
                  break;
              default:
                exit$1 = 1;
            }
            switch (exit$1) {
              case 1 :
                  var kind = node.kind;
                  _k = (function(k,kind){
                  return function (nodeStr) {
                    return k(nodeStr + stringifyQuanifier(kind));
                  }
                  }(k,kind));
                  _parents = {
                    hd: node,
                    tl: parents
                  };
                  _node = {
                    TAG: /* NonCaptureGroup */4,
                    node: node$1
                  };
                  continue ;
              case 2 :
                  var kind$1 = node.kind;
                  _k = (function(k,kind$1){
                  return function (nodeStr) {
                    return k(nodeStr + stringifyQuanifier(kind$1));
                  }
                  }(k,kind$1));
                  _node = node$1;
                  continue ;
              
            }
            break;
        case /* LookaheadExpr */3 :
            var kind$2 = node.kind;
            var lookahead = node.lookahead;
            _k = (function(parents,k,lookahead,kind$2){
            return function (nodeStr_a) {
              return stringify(lookahead, {
                          hd: {
                            TAG: /* NonCaptureGroup */4,
                            node: lookahead
                          },
                          tl: parents
                        }, (function (lookaheadStr) {
                            return k(nodeStr_a + ("(?" + ((
                                            kind$2 === "Negative" && kind$2 !== "Positive" ? "!" : "="
                                          ) + (lookaheadStr + ")"))));
                          }));
            }
            }(parents,k,lookahead,kind$2));
            _parents = {
              hd: node,
              tl: parents
            };
            _node = node.node;
            continue ;
        case /* NonCaptureGroup */4 :
            var node$2 = node.node;
            if (parents) {
              var tmp = parents.hd;
              if (typeof tmp !== "number") {
                switch (tmp.TAG | 0) {
                  case /* NonCaptureGroup */4 :
                  case /* CaptureGroup */5 :
                      _node = node$2;
                      continue ;
                  default:
                    
                }
              }
              
            }
            _k = (function(k){
            return function (nodeStr) {
              return k("(?:" + (nodeStr + ")"));
            }
            }(k));
            _parents = {
              hd: node,
              tl: parents
            };
            _node = node$2;
            continue ;
        case /* CaptureGroup */5 :
            var name = node.name;
            var node$3 = node.node;
            if (name !== undefined) {
              _k = (function(k,name){
              return function (nodeStr) {
                return k("(?<" + (name + (">" + (nodeStr + ")"))));
              }
              }(k,name));
              _parents = {
                hd: node,
                tl: parents
              };
              _node = node$3;
              continue ;
            }
            _k = (function(k){
            return function (nodeStr) {
              return k("(" + (nodeStr + ")"));
            }
            }(k));
            _parents = {
              hd: node,
              tl: parents
            };
            _node = node$3;
            continue ;
        
      }
    };
  };
  return stringify(node, parents, id);
}

function stringify(param) {
  return {
          source: param.prefix + (stringifyNode(param.node, /* [] */0) + param.suffix),
          flags: Belt_SetString.toArray(param.flags).join("")
        };
}

var stringifyFlags = RegexAst.flagsToString;

export {
  stringifyFlags ,
  stringifyQuanifier ,
  stringifyNode ,
  stringify ,
  
}
/* RegexAst Not a pure module */
